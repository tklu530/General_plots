
#einige Beispiele zu den Metalinsen, die am besten ueber copy-paste einzufuegen sind


#1.: Metalinse
"""
#generelle Vordefinition
n1 = n3 = 1.    #Brindex ueber und unter der Struktur
LAMBDA_x = LAMBDA_y = 0.25  #Periode einer Zelle
thickness = 1.25   #Achtung: hierbei sind die z-Koord der Plotpunkte, nicht unbedingt die wahre Dicke der Struktur wichtig
wavelength = 0.532   #Wellenlaenge der eingehenden Welle oder Array bei Durchlauf

lens_diam = LAMBDA_x * 1200.   #Hilfsvariable fuer die Geometrien; hier als Linsendurchmesser betrachtet
samps_per_cell_x = samps_per_cell_y = 4   #Anzahl der Feldsamplingpunkte pro Achse einer Zelle, gerade oder ungerade -> egal
Lx = Ly = lens_diam   #Kantenlaenge der xy Fourierflaeche, ebenfalls gerade und Vielfaches einer Zelle

phi = 0. / 180. * np.pi  #Eingangswinkel der Hauptachse des Eingangsstrahls
theta = 0. / 180. * np.pi    #Achtung!: muessen exakt mit den Eingangswinkeln der RCWA uebereinstimmen; Simpakete der RCWA
#im Fall ohne Beugung gelten diese nur fuer die eine jeweilige Winkelkombination


#Code arbeitet als Stacks; mehrere structure-Objekte werden uebereinandergesetzt
lens_one = structure(wavelength, n1, n3, Lx, Ly, samps_per_cell_x, samps_per_cell_y, LAMBDA_x, LAMBDA_y, thickness, theta, phi)   #ein Objekt definiert
#fuer jedes Objekt existiert ein eigenes Koordsystem mit 0 und thickness

lens_one.create_ellipse(a=lens_diam/2., b=lens_diam/2.)   #Hilfsform setzen; Form des Eingangsfeldes im Koordsys des Eingangsstrahls
lens_one.set_homog_wave(max_scaling=1.,center=(0.,0.),plot=False,easy=True)  #setze Eingangsfeld des Objektes durch eine homogene Welle


elemente = np.array([
            [0.1, 0.], #0
            [0.11, 0.], #1
            [0.12, 0.], #2
            [0.13, 0.], #3
            [0.14, 0.], #4
            [0.15, 0.], #5
            [0.16, 0.], #6
            [0.17, 0.], #7
            [0.18, 0.], #8
            [0.19, 0.], #9
            [0.2, 0.]]) #10
#die alten Werte
elemente = np.array([
            [0.1, 2.91360110096], #0
            [0.11, 2.58827424224], #1
            [0.12, 2.16495801334], #2
            [0.13, 1.73599295123], #3
            [0.14, 1.13217457927], #4
            [0.15, 0.693282875855], #5
            [0.16, -0.0869849982313], #6
            [0.17, -0.776945165025], #7
            [0.18, -1.48297343671], #8
            [0.19, -2.06904195467], #9
            [0.2, -2.76882466923]]) #10

elemente[:,0] = elemente[:,0] * 1000.  #wegen Einlese
lens_one.elemente = elemente    #dem Objekt zuweisen

path = "E:/Optik/Simulationen/Metalinse_Nanoletters/Daten/"
#lens_one.read_in_field(path=path+"Efield_R_ohne_ein_",space='R',component='x')  #Einlesen der Daten und Setzen des Feldes
lens_one.read_in_field(path=path+"Efield_T_",space='T',component='x', get_phase=True)  #Phasenshift der Transmission soll die Linse bestimmen

lens_one.create_ellipse(a=lens_diam/2., b=lens_diam/2.)  #Hilfsform setzen; Maske in der xy-Ebene bei z = 0, in welcher Zellen bestueckt werden
# ausserhalb wird das Feld zu Null gesetzt

f = 200.   #Brennweite in Mikrometern; beachten, ab wo gemessen wird (z=0 oder Unterseite der Linse)
x = np.linspace(-Lx / 2,Lx / 2,lens_one.Mx)
y = np.linspace(-Ly / 2,Ly / 2,lens_one.My)
xv, yv = np.meshgrid(x,y)
phase_map = 2 * np.pi - 2 * np.pi / wavelength * (np.sqrt(xv ** 2 + yv ** 2 + f ** 2) - f)   #Zuordnungsfunktion 
phase_map = np.mod(phase_map,2 * np.pi) - np.pi

lens_one.set_mask(phase_map, min_val = -np.pi, max_val = np.pi, plot=True, f=f)  #Setzen der Feldbildmaske

#die einfachen xy-Plots
lens_one.calculate(z=thickness+f,orient='xy',fourier=False,line=0.,R_mode="aus")

temp = lens_one.E_plot
#lens_one.plot_field(log=False, write_out=False, airy=lens_diam/2., mode="Abs", down=0)


lens_one.read_in_field(path=path+"Efield_T_",space='T',component='y', get_phase=False)  #Phasenshift der Transmission soll die Linse bestimmen

lens_one.calculate(z=thickness+f,orient='xy',fourier=False,line=0.,R_mode="aus")

lens_one.E_plot = temp * np.conjugate(temp) + lens_one.E_plot * np.conjugate(lens_one.E_plot)  #zu plottendes Betragsquadrat
lens_one.plot_field(log=False, write_out=False, airy=lens_diam/2., mode="Abs", down=0)


z=np.linspace(0.,2*f,100)   #lens_diam und f verkleinern!
lens_one.calculate(z=thickness+z,orient='xz',fourier=False,line=0.,R_mode="aus")

lens_one.plot_field(log=False, write_out=False, airy='None', mode="Abs", down=0)



#Speicher raeumen
del lens_one
"""










#2.: Teleskop
"""
#generelle Vordefinition
n1 = n3 = 1.    #Brindex ueber und unter der Struktur
LAMBDA_x = LAMBDA_y = 0.25  #Periode einer Zelle
thickness = 1.25   #Achtung: hierbei sind die z-Koord der Plotpunkte, nicht unbedingt die wahre Dicke der Struktur wichtig
wavelength = 0.532   #Wellenlaenge der eingehenden Welle oder Array bei Durchlauf

lens_diam = LAMBDA_x * 800.   #Hilfsvariable fuer die Geometrien; hier als Linsendurchmesser betrachtet
samps_per_cell_x = samps_per_cell_y = 2   #Anzahl der Feldsamplingpunkte pro Achse einer Zelle, gerade oder ungerade -> egal
Lx = Ly = lens_diam   #Kantenlaenge der xy Fourierflaeche, ebenfalls gerade und Vielfaches einer Zelle

phi = 0. / 180. * np.pi  #Eingangswinkel der Hauptachse des Eingangsstrahls
theta = 0. / 180. * np.pi    #Achtung!: muessen exakt mit den Eingangswinkeln der RCWA uebereinstimmen; Simpakete der RCWA
#im Fall ohne Beugung gelten diese nur fuer die eine jeweilige Winkelkombination


#Code arbeitet als Stacks; mehrere structure-Objekte werden uebereinandergesetzt
lens_one = structure(wavelength, n1, n3, Lx, Ly, samps_per_cell_x, samps_per_cell_y, LAMBDA_x, LAMBDA_y, thickness, theta, phi)   #ein Objekt definiert
#fuer jedes Objekt existiert ein eigenes Koordsystem mit 0 und thickness

rad = Lx/50. 
delta_y = Ly/6.
delta_x = Lx/6.
eingang = create_ellipse_util((Lx,Ly),rad,rad, trans=(-delta_y,-delta_x), intern=(lens_one.My,lens_one.Mx))  
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(-delta_y,0.), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(-delta_y,delta_x), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(0.,-delta_x), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(0.,0.), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(0.,delta_x), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(delta_y,-delta_x), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(delta_y,0.), intern=(lens_one.My,lens_one.Mx))
eingang += create_ellipse_util((Lx,Ly),rad,rad, trans=(delta_y,delta_x), intern=(lens_one.My,lens_one.Mx))
lens_one.form = eingang  #Hilfsform setzen; Form des Eingangsfeldes im Koordsys des Eingangsstrahls
lens_one.set_homog_wave(max_scaling=1.,center=(0.,0.),plot=True,easy=True)  #setze Eingangsfeld des Objektes durch eine homogene Welle

elemente = np.array([
            [0.1, 0.], #0
            [0.11, 0.], #1
            [0.12, 0.], #2
            [0.13, 0.], #3
            [0.14, 0.], #4
            [0.15, 0.], #5
            [0.16, 0.], #6
            [0.17, 0.], #7
            [0.18, 0.], #8
            [0.19, 0.], #9
            [0.2, 0.]]) #10

elemente[:,0] = elemente[:,0] * 1000.  #wegen Einlese
lens_one.elemente = elemente    #dem Objekt zuweisen

path = "E:/Optik/Simulationen/Metalinse_Nanoletters/Daten/"
#lens_one.read_in_field(path=path+"Efield_R_ohne_ein_",space='R',component='x')  #Einlesen der Daten und Setzen des Feldes
lens_one.read_in_field(path=path+"Efield_T_",space='T',component='x',get_phase=True)  #Phasenshift der Transmission soll die Linse bestimmen

lens_one.create_ellipse(a=lens_diam/2., b=lens_diam/2.)  #Hilfsform setzen; Maske in der xy-Ebene bei z = 0, in welcher Zellen bestueckt werden
# ausserhalb wird das Feld zu Null gesetzt

f = lens_diam/2.   #Brennweite in Mikrometern; beachten, ab wo gemessen wird (z=0 oder Unterseite der Linse)
x = np.linspace(-Lx / 2,Lx / 2,lens_one.Mx)
y = np.linspace(-Ly / 2,Ly / 2,lens_one.My)
xv, yv = np.meshgrid(x,y)
phase_map = 2 * np.pi - 2 * np.pi / wavelength * (np.sqrt(xv ** 2 + yv ** 2 + f ** 2) - f)   #Zuordnungsfunktion 
phase_map = np.mod(phase_map,2 * np.pi) - np.pi

lens_one.set_mask(phase_map, min_val = -np.pi, max_val = np.pi, plot=False, f=f)  #Setzen der Feldbildmaske

a = f * (1 - 1. / 4.)
lens_one.calculate(z=thickness+a,orient='xy',fourier=False,line=0.,R_mode="aus")

#lens_one.plot_field(log=False, write_out=False, airy=None, mode="Abs", down=0)



######################
#nun die zweite Linse
nx = np.linspace(0,lens_one.Mx-1,lens_one.Mx)  
ny = np.linspace(0,lens_one.My-1,lens_one.My)
nxv, nyv = np.meshgrid(nx,ny)
lens_one.field_inc = lens_one.E_plot[nyv.astype(int), nxv.astype(int)] 

lens_one.create_ellipse(a=lens_diam/2., b=lens_diam/2.)  #Hilfsform setzen; Maske in der xy-Ebene bei z = 0, in welcher Zellen bestueckt werden
# ausserhalb wird das Feld zu Null gesetzt

lens_diam_two = 0.25 * lens_diam   #zweiter 'virtueller' Linsendurchmesser
f = 0.25 * f   #Brennweite in Mikrometern; beachten, ab wo gemessen wird (z=0 oder Unterseite der Linse)
x = np.linspace(-Lx / 2,Lx / 2,lens_one.Mx)
y = np.linspace(-Ly / 2,Ly / 2,lens_one.My)
xv, yv = np.meshgrid(x,y)
phase_map = 2 * np.pi - 2 * np.pi / wavelength * (np.sqrt(xv ** 2 + yv ** 2 + f ** 2) - f)   #Zuordnungsfunktion 
phase_map_inv = 2. * np.pi - phase_map   #unten
phase_map_inv = np.mod(phase_map_inv, 2*np.pi) - np.pi#Phasenkarte invertieren
lens_one.set_mask(phase_map_inv, min_val = -np.pi, max_val = np.pi, plot=False, f=f)  #Setzen der Feldbildmaske

lens_one.calculate(z=thickness+f,orient='xy',fourier=False,line=0.,R_mode="aus")

lens_one.plot_field(log=False, write_out=False, airy=None, mode="Abs", down=10)

E_field_x = lens_one.E_plot




### die y-Komponente
lens_one.form = eingang  #Hilfsform setzen; Form des Eingangsfeldes im Koordsys des Eingangsstrahls
lens_one.set_homog_wave(max_scaling=1.,center=(0.,0.),plot=True,easy=True)  #setze Eingangsfeld des Objektes durch eine homogene Welle

#lens_one.read_in_field(path=path+"Efield_R_ohne_ein_",space='R',component='x')  #Einlesen der Daten und Setzen des Feldes
lens_one.read_in_field(path=path+"Efield_T_",space='T',component='y',get_phase=False)  #Phasenshift der Transmission soll die Linse bestimmen

lens_one.create_ellipse(a=lens_diam/2., b=lens_diam/2.)  #Hilfsform setzen; Maske in der xy-Ebene bei z = 0, in welcher Zellen bestueckt werden
# ausserhalb wird das Feld zu Null gesetzt

f = lens_diam/2.   #Brennweite in Mikrometern; beachten, ab wo gemessen wird (z=0 oder Unterseite der Linse)
x = np.linspace(-Lx / 2,Lx / 2,lens_one.Mx)
y = np.linspace(-Ly / 2,Ly / 2,lens_one.My)
xv, yv = np.meshgrid(x,y)
phase_map = 2 * np.pi - 2 * np.pi / wavelength * (np.sqrt(xv ** 2 + yv ** 2 + f ** 2) - f)   #Zuordnungsfunktion 
phase_map = np.mod(phase_map,2 * np.pi) - np.pi

lens_one.set_mask(phase_map, min_val = -np.pi, max_val = np.pi, plot=True, f=f)  #Setzen der Feldbildmaske

a = f * (1 - 1. / 4.)
lens_one.calculate(z=thickness+a,orient='xy',fourier=False,line=0.,R_mode="aus")

#lens_one.plot_field(log=False, write_out=False, airy=None, mode="Abs", down=0)



######################
#nun die zweite Linse
nx = np.linspace(0,lens_one.Mx-1,lens_one.Mx)  
ny = np.linspace(0,lens_one.My-1,lens_one.My)
nxv, nyv = np.meshgrid(nx,ny)
lens_one.field_inc = lens_one.E_plot[nyv.astype(int), nxv.astype(int)] 

lens_one.create_ellipse(a=lens_diam/2., b=lens_diam/2.)  #Hilfsform setzen; Maske in der xy-Ebene bei z = 0, in welcher Zellen bestueckt werden
# ausserhalb wird das Feld zu Null gesetzt

lens_diam_two = 0.25 * lens_diam   #zweiter 'virtueller' Linsendurchmesser
f = 0.25 * f   #Brennweite in Mikrometern; beachten, ab wo gemessen wird (z=0 oder Unterseite der Linse)
x = np.linspace(-Lx / 2,Lx / 2,lens_one.Mx)
y = np.linspace(-Ly / 2,Ly / 2,lens_one.My)
xv, yv = np.meshgrid(x,y)
phase_map = 2 * np.pi - 2 * np.pi / wavelength * (np.sqrt(xv ** 2 + yv ** 2 + f ** 2) - f)   #Zuordnungsfunktion 
phase_map_inv = 2. * np.pi - phase_map   #unten
phase_map_inv = np.mod(phase_map_inv, 2*np.pi) - np.pi#Phasenkarte invertieren
lens_one.set_mask(phase_map_inv, min_val = -np.pi, max_val = np.pi, plot=True, f=f)  #Setzen der Feldbildmaske

lens_one.calculate(z=thickness+f,orient='xy',fourier=False,line=0.,R_mode="aus")

#lens_one.plot_field(log=False, write_out=False, airy=None, mode="Abs", down=0)

E_field_y = lens_one.E_plot
lens_one.E_plot = E_field_x * np.conjugate(E_field_x) + E_field_y * np.conjugate(E_field_y)  #zu plottendes Betragsquadrat
lens_one.plot_field(log=False, write_out=False, airy=None, mode="Abs", down=0)



#Speicher raeumen
del lens_one
"""





